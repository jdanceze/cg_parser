package ppg.spec;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;
import java.util.Vector;
import ppg.PPG;
import ppg.PPGError;
import ppg.atoms.Nonterminal;
import ppg.atoms.Production;
import ppg.atoms.SemanticAction;
import ppg.atoms.SymbolList;
import ppg.cmds.Command;
import ppg.cmds.DropCmd;
import ppg.cmds.ExtendCmd;
import ppg.cmds.NewProdCmd;
import ppg.cmds.OverrideCmd;
import ppg.cmds.TransferCmd;
import ppg.code.ScanCode;
import ppg.lex.Lexer;
import ppg.parse.Parser;
import ppg.util.CodeWriter;
/* loaded from: gencallgraphv3.jar:polyglot-2006.jar:ppg/spec/PPGSpec.class */
public class PPGSpec extends Spec {
    private String include;
    private Vector commands;
    private Vector code;
    private Spec parent;
    private Vector startSyms;

    public PPGSpec(String incFile, String pkg, Vector imp, Vector codeParts, Vector syms, Vector precedence, Vector startList, Vector cmds) {
        this.include = incFile;
        this.packageName = pkg;
        this.imports = imp;
        this.code = codeParts;
        this.symbols = syms;
        this.prec = precedence;
        this.startSyms = startList;
        this.commands = cmds;
        this.parent = null;
    }

    public boolean isMultiStartSymbol() {
        return this.startSyms.size() > 1;
    }

    public void patchMultiStartSymbols(CUPSpec cupSpec) {
        if (!isMultiStartSymbol()) {
            cupSpec.setStart((String) this.startSyms.elementAt(0));
            return;
        }
        String parseCode = new StringBuffer().append("").append("Symbol ").append("ppg_curr_sym").append(";\n\n").toString();
        Vector tokens = new Vector();
        for (int i = 0; i < this.startSyms.size(); i += 2) {
            tokens.addElement(new String(new StringBuffer().append("JLGEN_TOKEN_").append(String.valueOf(i / 2)).toString()));
        }
        for (int i2 = 0; i2 < this.startSyms.size(); i2 += 2) {
            String str = (String) this.startSyms.elementAt(i2);
            String method = (String) this.startSyms.elementAt(i2 + 1);
            String token = (String) tokens.elementAt(i2 / 2);
            parseCode = new StringBuffer().append(parseCode).append("public Symbol ").append(method).append(" () throws Exception {\n").append("\t").append("ppg_curr_sym").append(" = ").append("new Symbol(").append(PPG.SYMBOL_CLASS_NAME).append(".").append(token).append(")").append(";\n").append("\t").append("return parse();\n}\n\n").toString();
        }
        cupSpec.parserCode.append(parseCode);
        String scanCodeAdd = new StringBuffer().append("\n// scan code generated by PPG\nif (").append("ppg_curr_sym").append("!= null) {\n").append("\tSymbol result = ").append("ppg_curr_sym").append(";\n").append("\t").append("ppg_curr_sym").append(" = null").append(";\n").append("\treturn result;\n").append("}\n").append("// end scan code generated by PPG\n\n").toString();
        if (cupSpec.scanCode != null) {
            cupSpec.scanCode.prepend(scanCodeAdd);
        } else {
            cupSpec.scanCode = new ScanCode(scanCodeAdd);
        }
        cupSpec.setStart("multi_start_symbool");
        Nonterminal startNT = new Nonterminal("multi_start_symbool", null);
        Vector newSymbols = new Vector();
        newSymbols.addElement("multi_start_symbool");
        SymbolList sl = new SymbolList(1, null, newSymbols);
        Vector addedSymbols = new Vector();
        addedSymbols.addElement(sl);
        cupSpec.addSymbols(addedSymbols);
        SymbolList tokenList = new SymbolList(0, "Symbol", tokens);
        Vector addedTokens = new Vector();
        addedTokens.addElement(tokenList);
        cupSpec.addSymbols(addedTokens);
        Vector rhs = new Vector();
        for (int i3 = 0; i3 < this.startSyms.size(); i3 += 2) {
            Vector rhsPart = new Vector();
            String startSym = (String) this.startSyms.elementAt(i3);
            String token2 = (String) tokens.elementAt(i3 / 2);
            rhsPart.addElement(new Nonterminal(token2, null));
            rhsPart.addElement(new Nonterminal(startSym, "s"));
            rhsPart.addElement(new SemanticAction("RESULT = s;"));
            rhs.addElement(rhsPart);
        }
        Production p = new Production(startNT, rhs);
        cupSpec.addProductions(p);
    }

    @Override // ppg.spec.Spec
    public void parseChain(String basePath) {
        File file = null;
        String simpleName = this.include;
        try {
            InputStream is = ClassLoader.getSystemResourceAsStream(this.include);
            if (is != null) {
                PPG.DEBUG(new StringBuffer().append("found ").append(this.include).append(" as a resource").toString());
            } else {
                String fullPath = new StringBuffer().append(basePath == "" ? "" : new StringBuffer().append(basePath).append(System.getProperty("file.separator")).toString()).append(this.include).toString();
                PPG.DEBUG(new StringBuffer().append("looking for ").append(fullPath).append(" as a file").toString());
                file = new File(fullPath);
                is = new FileInputStream(file);
                simpleName = file.getName();
            }
            Lexer lex = new Lexer(is, simpleName);
            Parser parser = new Parser(simpleName, lex);
            PPG.DEBUG(new StringBuffer().append("parsing ").append(simpleName).toString());
            parser.parse();
            this.parent = (Spec) Parser.getProgramNode();
            is.close();
        } catch (FileNotFoundException e) {
            System.out.println(new StringBuffer().append(PPG.HEADER).append(simpleName).append(" not found.").toString());
            System.exit(1);
        } catch (Exception e2) {
            System.out.println(new StringBuffer().append("ppg: Exception: ").append(e2.getMessage()).toString());
            System.exit(1);
        }
        this.parent.setChild(this);
        String parentDir = null;
        if (file != null) {
            parentDir = file.getParent();
        }
        this.parent.parseChain(parentDir == null ? "" : parentDir);
    }

    @Override // ppg.spec.Spec
    public CUPSpec coalesce() throws PPGError {
        CUPSpec combined = this.parent.coalesce();
        CUPSpec newSpec = (CUPSpec) combined.clone();
        newSpec.setPkgName(this.packageName);
        newSpec.addImports(this.imports);
        if (this.prec == null) {
            newSpec.prec.removeAllElements();
        } else if (this.prec.size() != 0) {
            newSpec.prec.removeAllElements();
            newSpec.prec.addAll(this.prec);
        }
        newSpec.replaceCode(this.code);
        newSpec.addSymbols(this.symbols);
        if (this.child == null) {
            patchMultiStartSymbols(newSpec);
        }
        processTransferL(combined, newSpec);
        processDrop(combined, newSpec);
        processOverride(combined, newSpec);
        processTransferR(combined, newSpec);
        processExtend(combined, newSpec);
        processNew(combined, newSpec);
        newSpec.removeEmptyProductions();
        return newSpec;
    }

    private void processDrop(CUPSpec combined, CUPSpec newSpec) throws PPGError {
        for (int i = 0; i < this.commands.size(); i++) {
            Command cmd = (Command) this.commands.elementAt(i);
            if (cmd instanceof DropCmd) {
                DropCmd drop = (DropCmd) cmd;
                if (drop.isProdDrop()) {
                    newSpec.dropProductions(drop.getProduction());
                } else {
                    Vector symbols = drop.getSymbols();
                    for (int j = 0; j < symbols.size(); j++) {
                        String sym = (String) symbols.elementAt(j);
                        newSpec.dropSymbol(sym);
                        newSpec.dropAllProductions(sym);
                    }
                }
            }
        }
    }

    private void processOverride(CUPSpec combined, CUPSpec newSpec) {
        for (int i = 0; i < this.commands.size(); i++) {
            Command cmd = (Command) this.commands.elementAt(i);
            if (cmd instanceof OverrideCmd) {
                OverrideCmd override = (OverrideCmd) cmd;
                newSpec.dropProductions(override.getLHS());
                newSpec.addProductions(override.getProduction());
            }
        }
    }

    private void processExtend(CUPSpec combined, CUPSpec newSpec) {
        for (int i = 0; i < this.commands.size(); i++) {
            Command cmd = (Command) this.commands.elementAt(i);
            if (cmd instanceof ExtendCmd) {
                ExtendCmd extend = (ExtendCmd) cmd;
                newSpec.addProductions(extend.getProduction());
            }
        }
    }

    private void processTransferL(CUPSpec combined, CUPSpec newSpec) {
        for (int i = 0; i < this.commands.size(); i++) {
            Command cmd = (Command) this.commands.elementAt(i);
            if (cmd instanceof TransferCmd) {
                TransferCmd transfer = (TransferCmd) cmd;
                transfer.getSource();
                Vector prodList = transfer.getTransferList();
                Production prod = (Production) ((Production) prodList.elementAt(0)).clone();
                for (int j = 1; j < prodList.size(); j++) {
                    Production prodNew = (Production) prodList.elementAt(j);
                    prod.union((Production) prodNew.clone());
                }
                prod.setLHS(transfer.getSource());
                newSpec.dropProductions(prod);
            }
        }
    }

    private void processTransferR(CUPSpec combined, CUPSpec newSpec) {
        for (int i = 0; i < this.commands.size(); i++) {
            Command cmd = (Command) this.commands.elementAt(i);
            if (cmd instanceof TransferCmd) {
                TransferCmd transfer = (TransferCmd) cmd;
                Vector prodList = transfer.getTransferList();
                for (int j = 0; j < prodList.size(); j++) {
                    Production prod = (Production) prodList.elementAt(j);
                    Nonterminal target = prod.getLHS();
                    prod.setLHS(transfer.getSource());
                    Production prodTransfer = combined.findProduction(prod);
                    prodTransfer.setLHS(target);
                    newSpec.addProductions(prodTransfer);
                }
            }
        }
    }

    private void processNew(CUPSpec combined, CUPSpec newSpec) {
        for (int i = 0; i < this.commands.size(); i++) {
            Command cmd = (Command) this.commands.elementAt(i);
            if (cmd instanceof NewProdCmd) {
                NewProdCmd newProd = (NewProdCmd) cmd;
                newSpec.addProductions(newProd.getProduction());
            }
        }
    }

    @Override // ppg.parse.Unparse
    public void unparse(CodeWriter cw) {
        cw.begin(0);
        if (this.include != null) {
            cw.write(new StringBuffer().append(this.include).append("\n").toString());
        }
        if (this.commands != null) {
            for (int i = 0; i < this.commands.size(); i++) {
                ((Command) this.commands.elementAt(i)).unparse(cw);
            }
        }
        cw.end();
    }
}
